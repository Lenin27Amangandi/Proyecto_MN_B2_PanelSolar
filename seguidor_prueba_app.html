<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Seguidor Solar Interactivo</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --primary: #00d4ff;
            --secondary: #ff6b00;
            --accent: #ffeb3b;
            --dark: #0d0d1a;
            --dark-card: #1a1a2e;
            --text: #ffffff;
            --text-dim: #a0a0b0;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff3366;
            --glow-blue: rgba(0, 212, 255, 0.4);
            --glow-orange: rgba(255, 107, 0, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 15% 30%, rgba(0, 212, 255, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 85% 70%, rgba(255, 107, 0, 0.15) 0%, transparent 40%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 212, 255, 0.03) 2px, rgba(0, 212, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 0;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 0 0, 0 0, 0 100px; }
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 60px 20px 40px;
            margin-bottom: 40px;
            position: relative;
        }

        h1 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 4rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: neonPulse 3s ease-in-out infinite;
        }

        @keyframes neonPulse {
            0%, 100% { filter: drop-shadow(0 0 20px var(--glow-blue)); }
            50% { filter: drop-shadow(0 0 40px var(--glow-orange)); }
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-dim);
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .status-bar {
            background: linear-gradient(135deg, var(--dark-card), rgba(0, 212, 255, 0.1));
            border: 2px solid var(--primary);
            border-radius: 10px;
            padding: 20px 30px;
            margin-bottom: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            box-shadow: 0 10px 40px var(--glow-blue);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-label {
            color: var(--text-dim);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-value {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--accent);
        }

        .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: blink 2s ease-in-out infinite;
        }

        .led.active {
            background: var(--success);
            box-shadow: 0 0 15px var(--success);
        }

        .led.standby {
            background: var(--warning);
            box-shadow: 0 0 15px var(--warning);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .control-panel {
            background: var(--dark-card);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--accent), var(--primary));
            background-size: 300% 300%;
            border-radius: 15px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
            animation: gradientShift 6s ease infinite;
        }

        .control-panel:hover::before {
            opacity: 0.3;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .control-panel h2 {
            font-family: 'Rajdhani', sans-serif;
            color: var(--primary);
            margin-bottom: 30px;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-panel h2::before {
            content: '‚ñ∏';
            color: var(--secondary);
            font-size: 2.5rem;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .input-group {
            position: relative;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: var(--text-dim);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
        }

        input, select {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 212, 255, 0.3);
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            border-radius: 8px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 20px var(--glow-blue);
            background: rgba(0, 212, 255, 0.05);
        }

        button {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 5px 25px var(--glow-blue);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 35px var(--glow-orange);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .data-display {
            background: var(--dark-card);
            border: 2px solid rgba(255, 107, 0, 0.3);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
        }

        .data-display h2 {
            font-family: 'Rajdhani', sans-serif;
            color: var(--secondary);
            margin-bottom: 25px;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 107, 0, 0.1));
            border: 2px solid var(--primary);
            border-radius: 10px;
            padding: 25px;
            text-align: center;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px var(--glow-blue);
            border-color: var(--accent);
        }

        .stat-box::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
        }

        .stat-number {
            font-family: 'Rajdhani', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .stat-description {
            color: var(--text-dim);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .chart-wrapper {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .viz-3d {
            width: 100%;
            height: 700px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 40px var(--glow-blue);
            margin: 30px 0;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 25px;
            font-size: 0.9rem;
        }

        .data-table th {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 15px;
            text-align: left;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }

        .data-table tr:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        .alert {
            padding: 20px 25px;
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 15px;
            animation: slideIn 0.5s ease;
            border-left: 4px solid;
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .alert.success {
            background: rgba(0, 255, 136, 0.15);
            border-color: var(--success);
            color: var(--success);
        }

        .alert.warning {
            background: rgba(255, 170, 0, 0.15);
            border-color: var(--warning);
            color: var(--warning);
        }

        .alert.info {
            background: rgba(0, 212, 255, 0.15);
            border-color: var(--primary);
            color: var(--primary);
        }

        .loading {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid var(--text-dim);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .info-panel {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid var(--primary);
            padding: 20px 25px;
            margin: 25px 0;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.8;
        }

        .info-panel strong {
            color: var(--accent);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }

            .input-grid {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }

        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 10px;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px var(--glow-blue);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° TRACKER SIMULATOR ‚ö°</h1>
            <p class="subtitle">Sistema de Seguimiento Solar Optimizado</p>
        </header>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span class="led active" id="system-led"></span>
                <span class="status-label">Sistema:</span>
                <span class="status-value" id="system-status">LISTO</span>
            </div>
            <div class="status-item">
                <span class="status-label">Ubicaci√≥n:</span>
                <span class="status-value">Quito, Ecuador</span>
            </div>
            <div class="status-item">
                <span class="status-label">Coordenadas:</span>
                <span class="status-value">-0.2106¬∞, -78.4916¬∞</span>
            </div>
            <div class="status-item">
                <span class="status-label">Datos:</span>
                <span class="status-value" id="data-count">0 puntos</span>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <h2>Panel de Control</h2>

            <div class="info-panel">
                <strong>üìã Instrucciones:</strong> Selecciona el rango de horas a simular. El sistema calcular√° 
                autom√°ticamente los √°ngulos √≥ptimos del panel solar para cada intervalo de 10 minutos.
                Durante la noche (18:00-06:00), el panel se mover√° gradualmente desde la posici√≥n del atardecer 
                hacia la posici√≥n del amanecer.
            </div>

            <div class="input-grid">
                <div class="input-group">
                    <label>üïê Hora de Inicio (0-23)</label>
                    <input type="number" id="hora-inicio" min="0" max="23" value="6" placeholder="Ej: 6">
                </div>
                <div class="input-group">
                    <label>üïë Hora de Fin (0-23)</label>
                    <input type="number" id="hora-fin" min="0" max="23" value="18" placeholder="Ej: 18">
                </div>
                <div class="input-group">
                    <label>üìÖ Fecha de Simulaci√≥n</label>
                    <input type="date" id="fecha-sim" value="">
                </div>
            </div>

            <div class="button-group">
                <button onclick="iniciarSimulacion()">üöÄ INICIAR SIMULACI√ìN</button>
                <button onclick="limpiarDatos()">üóëÔ∏è LIMPIAR</button>
                <button onclick="exportarCSV()" id="btn-export" disabled>üíæ EXPORTAR CSV</button>
            </div>

            <div id="progress-container" style="display: none;">
                <div class="progress-container">
                    <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
                </div>
                <p style="text-align: center; color: var(--text-dim); margin-top: 10px;">
                    <span id="progress-text">Calculando...</span>
                </p>
            </div>
        </div>

        <!-- Results Display -->
        <div id="results-section" style="display: none;">
            <!-- Statistics -->
            <div class="data-display">
                <h2>üìä Estad√≠sticas de Simulaci√≥n</h2>
                <div class="stats-grid" id="stats-grid"></div>
            </div>

            <!-- 3D Visualization -->
            <div class="data-display">
                <h2>üéÆ Visualizaci√≥n 3D Interactiva</h2>
                <div class="info-panel">
                    <strong>üéØ Gemelo Digital:</strong> Visualizaci√≥n en tiempo real del panel solar (azul) 
                    siguiendo la trayectoria del sol (naranja). Use los controles de Plotly para rotar, 
                    hacer zoom y reproducir la animaci√≥n.
                </div>
                <div id="plot-3d" class="viz-3d"></div>
            </div>

            <!-- Charts -->
            <div class="data-display">
                <h2>üìà Gr√°ficos de Rendimiento</h2>
                <div class="chart-wrapper">
                    <canvas id="comparison-chart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="motors-chart"></canvas>
                </div>
            </div>

            <!-- Data Table -->
            <div class="data-display">
                <h2>üìã Tabla de Datos</h2>
                <div style="overflow-x: auto;">
                    <table class="data-table" id="data-table">
                        <thead>
                            <tr>
                                <th>Hora</th>
                                <th>Azimuth Solar (¬∞)</th>
                                <th>Elevaci√≥n Solar (¬∞)</th>
                                <th>Roll Motor (¬∞)</th>
                                <th>Pitch Motor (¬∞)</th>
                                <th>Estado</th>
                            </tr>
                        </thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ CONFIGURACI√ìN ============
        const CONFIG = {
            LAT: -0.2105367,
            LON: -78.491614,
            TIMEZONE_OFFSET: -5, // UTC-5 para Ecuador
            ROLL_MIN: -60,
            ROLL_MAX: 60,
            PITCH_MIN: -45,
            PITCH_MAX: 45,
            REPOSO: [0, 0],
            INTERVALO_MINUTOS: 10
        };

        let simulationData = [];
        let comparisonChart = null;
        let motorsChart = null;

        // Inicializar fecha actual
        document.addEventListener('DOMContentLoaded', function() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('fecha-sim').value = today;
        });

        // ============ C√ÅLCULOS ASTRON√ìMICOS ============

        function degreesToRadians(deg) {
            return deg * Math.PI / 180;
        }

        function radiansToDegrees(rad) {
            return rad * 180 / Math.PI;
        }

        function julianDate(date) {
            const a = Math.floor((14 - (date.getMonth() + 1)) / 12);
            const y = date.getFullYear() + 4800 - a;
            const m = (date.getMonth() + 1) + 12 * a - 3;
            
            let jd = date.getDate() + Math.floor((153 * m + 2) / 5) + 365 * y + 
                     Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
            
            const hours = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
            jd += (hours - 12) / 24;
            
            return jd;
        }

        function calcularPosicionSolar(fecha, lat, lon) {
            const jd = julianDate(fecha);
            const jc = (jd - 2451545.0) / 36525.0;
            
            const L0 = (280.46646 + jc * (36000.76983 + jc * 0.0003032)) % 360;
            const M = (357.52911 + jc * (35999.05029 - 0.0001537 * jc)) % 360;
            
            const C = Math.sin(degreesToRadians(M)) * (1.914602 - jc * (0.004817 + 0.000014 * jc)) +
                      Math.sin(degreesToRadians(2 * M)) * (0.019993 - 0.000101 * jc) +
                      Math.sin(degreesToRadians(3 * M)) * 0.000289;
            
            const sunLon = L0 + C;
            const epsilon = 23.439291 - jc * 0.0130042;
            
            const ra = radiansToDegrees(Math.atan2(
                Math.cos(degreesToRadians(epsilon)) * Math.sin(degreesToRadians(sunLon)), 
                Math.cos(degreesToRadians(sunLon))
            ));
            
            const declination = radiansToDegrees(Math.asin(
                Math.sin(degreesToRadians(epsilon)) * Math.sin(degreesToRadians(sunLon))
            ));
            
            const gmst = (280.46061837 + 360.98564736629 * (jd - 2451545.0) + 
                          jc * jc * (0.000387933 - jc / 38710000.0)) % 360;
            
            const hourAngle = (gmst + lon - ra) % 360;
            
            const latRad = degreesToRadians(lat);
            const decRad = degreesToRadians(declination);
            const haRad = degreesToRadians(hourAngle);
            
            const elevation = radiansToDegrees(Math.asin(
                Math.sin(latRad) * Math.sin(decRad) + 
                Math.cos(latRad) * Math.cos(decRad) * Math.cos(haRad)
            ));
            
            let azimuth = radiansToDegrees(Math.atan2(
                Math.sin(haRad),
                Math.cos(haRad) * Math.sin(latRad) - Math.tan(decRad) * Math.cos(latRad)
            ));
            
            azimuth = (azimuth + 180) % 360;
            
            return { azimuth, elevation };
        }

        // ============ SIMULACI√ìN DEL PANEL ============

        function matrizRotacionX(theta) {
            const rad = degreesToRadians(theta);
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            return [
                [1, 0, 0],
                [0, c, -s],
                [0, s, c]
            ];
        }

        function matrizRotacionY(theta) {
            const rad = degreesToRadians(theta);
            const c = Math.cos(rad);
            const s = Math.sin(rad);
            return [
                [c, 0, s],
                [0, 1, 0],
                [-s, 0, c]
            ];
        }

        function multiplicarMatrizVector(matriz, vector) {
            return [
                matriz[0][0] * vector[0] + matriz[0][1] * vector[1] + matriz[0][2] * vector[2],
                matriz[1][0] * vector[0] + matriz[1][1] * vector[1] + matriz[1][2] * vector[2],
                matriz[2][0] * vector[0] + matriz[2][1] * vector[1] + matriz[2][2] * vector[2]
            ];
        }

        function simularPanel(roll, pitch) {
            const normalInicial = [0, 0, 1]; // Apuntando al cenit
            const Rx = matrizRotacionX(roll);
            const Ry = matrizRotacionY(pitch);
            
            // Aplicar rotaciones: primero Roll, luego Pitch
            const temp = multiplicarMatrizVector(Rx, normalInicial);
            const vectorPanel = multiplicarMatrizVector(Ry, temp);
            
            return vectorPanel;
        }

        function vectorSolar(azimuth, elevation) {
            const azRad = degreesToRadians(azimuth);
            const elRad = degreesToRadians(elevation);
            
            const x = Math.cos(elRad) * Math.sin(azRad);
            const y = Math.cos(elRad) * Math.cos(azRad);
            const z = Math.sin(elRad);
            
            return [x, y, z];
        }

        function productoPunto(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
        }

        function encontrarAngulosOptimos(azimuth, elevation) {
            if (elevation < 0) {
                return { roll: CONFIG.REPOSO[0], pitch: CONFIG.REPOSO[1], alignment: 0 };
            }

            const vSol = vectorSolar(azimuth, elevation);
            let bestRoll = 0, bestPitch = 0, bestAlignment = -1;

            // B√∫squeda por grilla
            for (let roll = CONFIG.ROLL_MIN; roll <= CONFIG.ROLL_MAX; roll += 2) {
                for (let pitch = CONFIG.PITCH_MIN; pitch <= CONFIG.PITCH_MAX; pitch += 2) {
                    const vPanel = simularPanel(roll, pitch);
                    const alignment = productoPunto(vSol, vPanel);
                    
                    if (alignment > bestAlignment) {
                        bestAlignment = alignment;
                        bestRoll = roll;
                        bestPitch = pitch;
                    }
                }
            }

            // Refinamiento
            for (let roll = bestRoll - 2; roll <= bestRoll + 2; roll += 0.5) {
                if (roll < CONFIG.ROLL_MIN || roll > CONFIG.ROLL_MAX) continue;
                for (let pitch = bestPitch - 2; pitch <= bestPitch + 2; pitch += 0.5) {
                    if (pitch < CONFIG.PITCH_MIN || pitch > CONFIG.PITCH_MAX) continue;
                    const vPanel = simularPanel(roll, pitch);
                    const alignment = productoPunto(vSol, vPanel);
                    
                    if (alignment > bestAlignment) {
                        bestAlignment = alignment;
                        bestRoll = roll;
                        bestPitch = pitch;
                    }
                }
            }

            return { roll: bestRoll, pitch: bestPitch, alignment: bestAlignment };
        }

        // ============ SIMULACI√ìN PRINCIPAL ============

        async function iniciarSimulacion() {
            const horaInicio = parseInt(document.getElementById('hora-inicio').value);
            const horaFin = parseInt(document.getElementById('hora-fin').value);
            const fechaSim = document.getElementById('fecha-sim').value;

            if (isNaN(horaInicio) || isNaN(horaFin)) {
                mostrarAlerta('Por favor ingresa horas v√°lidas (0-23)', 'warning');
                return;
            }

            if (!fechaSim) {
                mostrarAlerta('Por favor selecciona una fecha', 'warning');
                return;
            }

            // Limpiar datos anteriores
            simulationData = [];

            // Mostrar progress bar
            document.getElementById('progress-container').style.display = 'block';
            actualizarStatus('SIMULANDO...', 'standby');

            // Crear fechas
            const [year, month, day] = fechaSim.split('-').map(Number);
            let fechaInicio = new Date(year, month - 1, day, horaInicio, 0, 0);
            let fechaFin = new Date(year, month - 1, day, horaFin, 0, 0);

            // Si hora fin <= hora inicio, asumir que cruza medianoche
            if (horaFin <= horaInicio) {
                fechaFin.setDate(fechaFin.getDate() + 1);
            }

            // Calcular referencias para interpolaci√≥n nocturna
            const refAtardecer = new Date(year, month - 1, day, 18, 0, 0);
            const refAmanecer = new Date(year, month - 1, day + 1, 6, 0, 0);

            const posAtardecer = calcularPosicionSolar(refAtardecer, CONFIG.LAT, CONFIG.LON);
            const angAtardecer = encontrarAngulosOptimos(posAtardecer.azimuth, posAtardecer.elevation);

            const posAmanecer = calcularPosicionSolar(refAmanecer, CONFIG.LAT, CONFIG.LON);
            const angAmanecer = encontrarAngulosOptimos(posAmanecer.azimuth, posAmanecer.elevation);

            // Simulaci√≥n
            let tiempoActual = new Date(fechaInicio);
            const totalPuntos = Math.ceil((fechaFin - fechaInicio) / (CONFIG.INTERVALO_MINUTOS * 60 * 1000));
            let puntoActual = 0;

            while (tiempoActual <= fechaFin) {
                const hora = tiempoActual.getHours();
                const minuto = tiempoActual.getMinutes();

                const posSolar = calcularPosicionSolar(tiempoActual, CONFIG.LAT, CONFIG.LON);
                let roll, pitch, estado;

                if (hora >= 6 && hora < 18) {
                    // D√çA - tracking activo
                    const angulos = encontrarAngulosOptimos(posSolar.azimuth, posSolar.elevation);
                    roll = angulos.roll;
                    pitch = angulos.pitch;
                    estado = 'TRACKING';
                } else {
                    // NOCHE - interpolaci√≥n
                    const totalMinutosNoche = 12 * 60;
                    let minutosPasados;

                    if (hora >= 18) {
                        minutosPasados = (hora - 18) * 60 + minuto;
                    } else {
                        minutosPasados = (24 - 18) * 60 + (hora * 60) + minuto;
                    }

                    const progreso = Math.min(minutosPasados / totalMinutosNoche, 1.0);
                    roll = angAtardecer.roll + (angAmanecer.roll - angAtardecer.roll) * progreso;
                    pitch = angAtardecer.pitch + (angAmanecer.pitch - angAtardecer.pitch) * progreso;
                    estado = 'NOCTURNO';
                }

                simulationData.push({
                    hora: tiempoActual.toTimeString().substr(0, 5),
                    azimuth: posSolar.azimuth,
                    elevation: posSolar.elevation,
                    roll: roll,
                    pitch: pitch,
                    estado: estado
                });

                tiempoActual = new Date(tiempoActual.getTime() + CONFIG.INTERVALO_MINUTOS * 60 * 1000);
                puntoActual++;

                // Actualizar progreso
                const progreso = (puntoActual / totalPuntos) * 100;
                document.getElementById('progress-bar').style.width = progreso + '%';
                document.getElementById('progress-text').textContent = 
                    `Procesando: ${puntoActual} / ${totalPuntos} puntos (${Math.round(progreso)}%)`;

                // Permitir que la UI se actualice
                if (puntoActual % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Ocultar progress bar
            document.getElementById('progress-container').style.display = 'none';
            actualizarStatus('COMPLETADO', 'active');

            // Mostrar resultados
            mostrarResultados();
            mostrarAlerta('‚úÖ Simulaci√≥n completada con √©xito', 'success');
        }

        function mostrarResultados() {
            document.getElementById('results-section').style.display = 'block';
            document.getElementById('btn-export').disabled = false;
            
            actualizarEstadisticas();
            renderizarGraficos();
            renderizarTabla();
            renderizar3D();
            
            // Scroll suave a resultados
            document.getElementById('results-section').scrollIntoView({ behavior: 'smooth' });
        }

        function actualizarEstadisticas() {
            const trackingData = simulationData.filter(d => d.estado === 'TRACKING');
            const maxElevacion = Math.max(...simulationData.map(d => d.elevation));
            const minElevacion = Math.min(...simulationData.map(d => d.elevation));
            const avgRoll = simulationData.reduce((sum, d) => sum + d.roll, 0) / simulationData.length;
            const avgPitch = simulationData.reduce((sum, d) => sum + d.pitch, 0) / simulationData.length;

            const statsHTML = `
                <div class="stat-box">
                    <div class="stat-number">${simulationData.length}</div>
                    <div class="stat-description">Puntos de Datos</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${trackingData.length}</div>
                    <div class="stat-description">Puntos de Tracking</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${maxElevacion.toFixed(1)}¬∞</div>
                    <div class="stat-description">Elevaci√≥n M√°xima</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${avgRoll.toFixed(1)}¬∞</div>
                    <div class="stat-description">Roll Promedio</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${avgPitch.toFixed(1)}¬∞</div>
                    <div class="stat-description">Pitch Promedio</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${(trackingData.length * CONFIG.INTERVALO_MINUTOS / 60).toFixed(1)}h</div>
                    <div class="stat-description">Horas de Sol</div>
                </div>
            `;

            document.getElementById('stats-grid').innerHTML = statsHTML;
            document.getElementById('data-count').textContent = `${simulationData.length} puntos`;
        }

        function renderizarGraficos() {
            // Gr√°fico de comparaci√≥n
            const ctx1 = document.getElementById('comparison-chart');
            if (comparisonChart) comparisonChart.destroy();

            comparisonChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: simulationData.map(d => d.hora),
                    datasets: [
                        {
                            label: 'Elevaci√≥n Solar (¬∞)',
                            data: simulationData.map(d => d.elevation),
                            borderColor: '#ffeb3b',
                            backgroundColor: 'rgba(255, 235, 59, 0.1)',
                            tension: 0.4,
                            fill: true,
                            borderWidth: 3
                        },
                        {
                            label: 'Pitch Motor (¬∞)',
                            data: simulationData.map(d => d.pitch),
                            borderColor: '#00d4ff',
                            tension: 0.4,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            labels: { color: '#ffffff', font: { family: "'Rajdhani', sans-serif", size: 14 } }
                        },
                        title: {
                            display: true,
                            text: 'Comparaci√≥n: Elevaci√≥n Solar vs Pitch Motor',
                            color: '#00d4ff',
                            font: { family: "'Rajdhani', sans-serif", size: 18 }
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#a0a0b0' },
                            grid: { color: 'rgba(0, 212, 255, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#a0a0b0', maxRotation: 45, minRotation: 45 },
                            grid: { color: 'rgba(0, 212, 255, 0.1)' }
                        }
                    }
                }
            });

            // Gr√°fico de motores
            const ctx2 = document.getElementById('motors-chart');
            if (motorsChart) motorsChart.destroy();

            motorsChart = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels: simulationData.map(d => d.hora),
                    datasets: [
                        {
                            label: 'Roll Motor (¬∞)',
                            data: simulationData.map(d => d.roll),
                            borderColor: '#ff6b00',
                            tension: 0.4,
                            borderWidth: 2
                        },
                        {
                            label: 'Pitch Motor (¬∞)',
                            data: simulationData.map(d => d.pitch),
                            borderColor: '#00d4ff',
                            tension: 0.4,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            labels: { color: '#ffffff', font: { family: "'Rajdhani', sans-serif", size: 14 } }
                        },
                        title: {
                            display: true,
                            text: 'Movimiento de Motores Roll y Pitch',
                            color: '#ff6b00',
                            font: { family: "'Rajdhani', sans-serif", size: 18 }
                        }
                    },
                    scales: {
                        y: {
                            ticks: { color: '#a0a0b0' },
                            grid: { color: 'rgba(255, 107, 0, 0.1)' }
                        },
                        x: {
                            ticks: { color: '#a0a0b0', maxRotation: 45, minRotation: 45 },
                            grid: { color: 'rgba(255, 107, 0, 0.1)' }
                        }
                    }
                }
            });
        }

        function renderizarTabla() {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            simulationData.forEach(d => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${d.hora}</td>
                    <td>${d.azimuth.toFixed(2)}</td>
                    <td>${d.elevation.toFixed(2)}</td>
                    <td>${d.roll.toFixed(2)}</td>
                    <td>${d.pitch.toFixed(2)}</td>
                    <td style="color: ${d.estado === 'TRACKING' ? 'var(--success)' : 'var(--warning)'}">${d.estado}</td>
                `;
            });
        }

        function renderizar3D() {
            const frames = [];
            const sunPathX = [], sunPathY = [], sunPathZ = [];

            // Calcular trayectoria del sol
            simulationData.forEach(d => {
                if (d.elevation > 0) {
                    const azRad = degreesToRadians(d.azimuth);
                    const elRad = degreesToRadians(d.elevation);
                    sunPathX.push(Math.cos(elRad) * Math.sin(azRad) * 1.2);
                    sunPathY.push(Math.cos(elRad) * Math.cos(azRad) * 1.2);
                    sunPathZ.push(Math.sin(elRad) * 1.2);
                }
            });

            // Crear frames
            simulationData.forEach((d, i) => {
                const vSol = vectorSolar(d.azimuth, d.elevation);
                const vPanel = simularPanel(d.roll, d.pitch);

                // Esquinas del panel
                const size = 0.6;
                const Rx = matrizRotacionX(d.roll);
                const Ry = matrizRotacionY(d.pitch);
                
                const corners = [
                    [size, size, 0],
                    [-size, size, 0],
                    [-size, -size, 0],
                    [size, -size, 0]
                ].map(corner => {
                    const temp = multiplicarMatrizVector(Rx, corner);
                    return multiplicarMatrizVector(Ry, temp);
                });

                frames.push({
                    name: String(i),
                    data: [
                        // Sol
                        {
                            type: 'scatter3d',
                            mode: 'markers',
                            x: [vSol[0] * 1.2],
                            y: [vSol[1] * 1.2],
                            z: [vSol[2] * 1.2],
                            marker: { size: 12, color: '#ffeb3b' },
                            name: 'Sol'
                        },
                        // Rayo solar
                        {
                            type: 'scatter3d',
                            mode: 'lines',
                            x: [0, vSol[0] * 1.2],
                            y: [0, vSol[1] * 1.2],
                            z: [0, vSol[2] * 1.2],
                            line: { color: '#ff6b00', width: 3, dash: 'dash' },
                            name: 'Rayo Solar'
                        },
                        // Panel
                        {
                            type: 'mesh3d',
                            x: corners.map(c => c[0]),
                            y: corners.map(c => c[1]),
                            z: corners.map(c => c[2]),
                            i: [0, 0],
                            j: [1, 2],
                            k: [2, 3],
                            color: '#00d4ff',
                            opacity: 0.9,
                            name: 'Panel'
                        },
                        // Normal del panel
                        {
                            type: 'scatter3d',
                            mode: 'lines',
                            x: [0, vPanel[0]],
                            y: [0, vPanel[1]],
                            z: [0, vPanel[2]],
                            line: { color: '#00d4ff', width: 6 },
                            name: 'Normal Panel'
                        }
                    ]
                });
            });

            const layout = {
                scene: {
                    xaxis: { title: 'Este (X)', range: [-1.5, 1.5], color: '#a0a0b0' },
                    yaxis: { title: 'Norte (Y)', range: [-1.5, 1.5], color: '#a0a0b0' },
                    zaxis: { title: 'Zenith (Z)', range: [0, 1.5], color: '#a0a0b0' },
                    bgcolor: '#0d0d1a',
                    camera: { eye: { x: 1.5, y: 1.5, z: 1.2 } }
                },
                paper_bgcolor: '#0d0d1a',
                plot_bgcolor: '#0d0d1a',
                font: { color: '#ffffff', family: "'JetBrains Mono', monospace" },
                showlegend: true,
                legend: { bgcolor: 'rgba(26, 26, 46, 0.8)' },
                updatemenus: [{
                    type: 'buttons',
                    x: 0.1,
                    y: 0,
                    buttons: [
                        {
                            label: '‚ñ∂ PLAY',
                            method: 'animate',
                            args: [null, { frame: { duration: 50 }, fromcurrent: true }]
                        },
                        {
                            label: '‚ùö‚ùö PAUSE',
                            method: 'animate',
                            args: [[null], { frame: { duration: 0 }, mode: 'immediate' }]
                        }
                    ]
                }],
                sliders: [{
                    active: 0,
                    steps: frames.map((f, k) => ({
                        args: [[f.name], { frame: { duration: 50 }, mode: 'immediate' }],
                        label: simulationData[k].hora,
                        method: 'animate'
                    })),
                    currentvalue: { prefix: 'Hora: ', visible: true }
                }]
            };

            // Agregar trayectoria del sol
            const initialData = [
                ...frames[0].data,
                {
                    type: 'scatter3d',
                    mode: 'lines',
                    x: sunPathX,
                    y: sunPathY,
                    z: sunPathZ,
                    line: { color: '#ffeb3b', width: 2 },
                    opacity: 0.3,
                    name: 'Trayectoria Solar'
                }
            ];

            Plotly.newPlot('plot-3d', initialData, layout, { responsive: true }).then(() => {
                Plotly.addFrames('plot-3d', frames);
            });
        }

        // ============ UTILIDADES ============

        function limpiarDatos() {
            simulationData = [];
            document.getElementById('results-section').style.display = 'none';
            document.getElementById('btn-export').disabled = true;
            actualizarStatus('LISTO', 'active');
            document.getElementById('data-count').textContent = '0 puntos';
            mostrarAlerta('Datos limpiados', 'info');
        }

        function exportarCSV() {
            if (simulationData.length === 0) return;

            let csv = 'Hora,Azimuth Solar (¬∞),Elevaci√≥n Solar (¬∞),Roll Motor (¬∞),Pitch Motor (¬∞),Estado\n';
            
            simulationData.forEach(d => {
                csv += `${d.hora},${d.azimuth.toFixed(2)},${d.elevation.toFixed(2)},${d.roll.toFixed(2)},${d.pitch.toFixed(2)},${d.estado}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `simulacion_tracker_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);

            mostrarAlerta('CSV exportado exitosamente', 'success');
        }

        function actualizarStatus(texto, tipo) {
            document.getElementById('system-status').textContent = texto;
            const led = document.getElementById('system-led');
            led.className = 'led ' + tipo;
        }

        function mostrarAlerta(mensaje, tipo) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert ${tipo}`;
            alertDiv.innerHTML = `
                ${tipo === 'success' ? '‚úÖ' : tipo === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'} ${mensaje}
            `;
            
            const container = document.querySelector('.container');
            container.insertBefore(alertDiv, container.firstChild);
            
            setTimeout(() => alertDiv.remove(), 4000);
        }
    </script>
</body>
</html>
